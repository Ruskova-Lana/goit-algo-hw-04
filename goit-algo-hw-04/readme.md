# Порівняння алгоритмів сортування: Insertion Sort, Merge Sort та Timsort

## Теоретичний аналіз

| Алгоритм            | Найгірший випадок | Середній випадок | Найкращий випадок | Особливості |
|----------------------|------------------|------------------|-------------------|-------------|
| Insertion Sort       | O(n²)            | O(n²)            | O(n)              | Ефективний на малих та майже відсортованих масивах |
| Merge Sort           | O(n log n)       | O(n log n)       | O(n log n)        | Стабільний, але потребує додаткової пам’яті |
| Timsort (Python)     | O(n log n)       | O(n log n)       | O(n)              | Адаптивний: поєднання Merge Sort та Insertion Sort |


## Результати тестування

| Розмір масиву | Insertion Sort | Merge Sort | Timsort (Python) |
|---------------|----------------|------------|------------------|
| 1000 | 0.04309 сек | 0.00355 сек | 0.00021 сек |
| 5000 | 1.15973 сек | 0.02072 сек | 0.00123 сек |
| 10000 | 4.42499 сек | 0.04576 сек | 0.00249 сек |


## Висновки

1. **Insertion Sort** — дуже повільний на великих наборах даних, але швидкий на маленьких або майже відсортованих.
2. **Merge Sort** — стабільно швидкий, але не використовує локально відсортовані ділянки.
3. **Timsort (Python)** — найефективніший завдяки адаптивності: комбінує переваги Merge Sort і Insertion Sort.

✅ Отримані результати підтверджують теоретичний аналіз: **Timsort значно ефективніший** і саме тому використовується у Python у `sorted()` та `.sort()`.
